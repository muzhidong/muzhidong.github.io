# 网络基础
本篇是网络基础下篇，介绍运输层和应用层。

## 运输层
### 研究问题
应用进程间如何进行逻辑通信（连接应用）

### 端口与套接字
- 端口：软件端口，应用层的各种协议进程与运输实体进行层间交互的一种地址，只具有本地意义。标识进程的逻辑地址，有效值范围为0-65535，分服务端使用的端口号和客户端使用的端口号，前者又分系统端口号(范围0-1023，又称熟知端口号)和登记端口号(范围1024-49151，需按规定手续进行登记)，后者又叫短暂端口号，供客户进程暂时使用，可取值范围49152-65535

  常见的服务端使用的端口号如下，
  | 协议 | 端口号 | 用途 |
  |------|-------|-----|
  | HTTP | 80 | 浏览器与Web服务器间的通信 |
  | HTTPS | 443 | TSL加密的HTTP通信 |
  | FTP | 20/21 | 文件传输 |
  | SSH | 22 | 加密远程登录 |
  | Telnet | 23 | 不加密远程登录 |
  | SMTP | 25 | 邮件发送 |
  | POP3 | 110 | 接收邮件 |
  | IMAP | 143 | 接收和管理邮件 |
  | DNS | 53 | 域名解析 |
  | LDAP | 389 | 访问和维护分布式目录信息 |
  | TFTP | 69 | 简单的文件传输 |
  | NTP | 123 | 网络时间同步 |
  | SMB | 445 | 网络文件共享 |
  | IRC | 6667 | 即时聊天 |
  | SNMP | 161 | 管理和监控网络设备 |
  | MySQL | 3306 | 数据库存储 |
  | PostgreSQL | 5432 | 数据库存储 |
  | MSSQL | 1433 | 数据库存储 |
  | RDP | 3389 | 远程桌面连接 |

  > 查看已被使用的服务端使用的端口号：[iana.org](https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml)

- 套接字：TCP连接的端点，又称插口。表示如下：socket = (IP地址:端口号)

  TCP连接::= {socket1, socket2} = {(IP1:PORT1), (IP2:PORT2)}
  
  同个IP地址可以出现在多个不同TCP连接，同个端口号也可以出现在多个不同TCP连接

### TCP与UDP的特点
| 传输控制协议TCP | 用户数据报协议UDP |
| ------------- | --------------- |
| 面向连接       | 无连接           |
| 提供可靠交付的服务 | 尽最大努力交付，不保证可靠交付 |
| 面向字节流，数据最大长度(MSS)为536字节 | 面向报文，一次交付一个完整的报文，由网络层确定是否需要分片，存在效率问题 |
| 有拥塞控制      | 无拥塞控制 |
| 仅支持1对1的全双工通信，两端设有缓存 | 支持1对1、1对多、多对1、多对多的交互通信 |
| 首部长度最小20字节 | 首部长度仅8个字节（源端口、目的端口、长度、校验和）|
| 有确认、计时器、流量控制、连接管理等开销 | 一定情况会比较高效 |

### TCP首部结构
<style>
  .g-container {
    display:grid;
    grid-template-columns: repeat(16, 1fr);
    grid-template-rows: repeat(7, 50px);
    border-top:1px solid var(--vp-c-text-3, white);
    border-left:1px solid var(--vp-c-text-3, white);
    & > div {
      padding: 5px;
      border-right: 1px solid var(--vp-c-text-3, white);
      border-bottom: 1px solid var(--vp-c-text-3, white);
      text-align: center;
      line-height: 40px;
      white-space: nowrap;
    }
    & > div:is(:nth-child(1),:nth-child(9),:nth-child(11)) {
      grid-column: 1/9;
    }
    & > div:is(:nth-child(2),:nth-child(10),:nth-child(12)) {
      grid-column: 9/17;
    }
    & > div:is(:nth-child(3),:nth-child(4)) {
      grid-column: 1/17;
    }
    & > div:nth-child(5) {
      grid-column: 1/3;
    }
    & > div:nth-child(6) {
      grid-column: 3/6;
    }
    & > div:nth-child(7) {
      grid-column: 6/9;
    }
    & > div:nth-child(8) {
      grid-column: 9/17;
    }
  }
</style>
<div class="g-container">
  <div>源端口 (16位)</div>
  <div>目的端口 (16位)</div>
  <div>序列号 (32位)</div>
  <div>确认号 (32位)</div>
  <div>首部长度 (4位)</div>
  <div>保留(6位)</div>
  <div>控制代码 (6位)</div>
  <div>窗口大小 (16位)</div>
  <div>校验和 (16位)</div>
  <div>紧急指针(16位)</div>
  <div>选项(长度可变，不超过40字节)</div>
  <div>填充</div>
</div>

部分字段解释
- 确认号：期望收到对方下个报文段的第一个数据字节的序号。当确认号为N，表示到序号N-1为止的所有数据已正确收到
- 首部长度：单位是4字节，故最大60字节
- 标志位/控制代码：
    
  SYN：synchronous，建立联机
  
  ACK：acknowledgement，确认
  
  FIN：finish，结束

  PSH：push，传送
  
  RST：reset，重置
  
  URG：urgent，紧急
- 窗口：发送本报文段一方的接收可用窗口大小，非自身的发送窗口
- 校验和：同UDP校验和，伪首部、首部、数据拆为多个16位(2字节)，进行求和，最后取反
- 紧急指针：URG为1有效
- 选项：如扩大窗口选项(提升窗口大小上限)、时间戳选项(计算RTT、处理TCP序号超过2^32的情况)

### TCP在不可靠网络上实现可靠传输的工作原理
- 理想传输条件的特点
  - 传输信道不产生差错
  - 不管发送方以多快的速度发送数据，接收方总是来得及处理收到的数据
> 实际中是不可能满足以上条件的，第一点可以通过重传解决差错，第二点可以通过及时告知发送方适当降低发送数据的速度以应对接收方来不及处理收到的数据问题

- 停止等待协议(自动重传请求ARQ)

  重传和确认机制：
  - 出现差错：发送方超时重传(每发送完一个分组，保留其副本；分组和确认分组做编号；设置一个超时计时器，重传时间比平均往返时间长一些)
  - 确认丢失：接收方丢弃重复的分组，重传确认
  - 确认迟到：接收方丢弃重复的分组，重传确认；发送方收下迟到的确认但什么都不做

  优缺点：简单，但信道利用率(U=TD/(发送分组时间TD+往返时间RTT+发送确认分组时间TA))低。使用流水线传输(连续发送多个分组)可以解决信道利用率低问题。连续ARQ协议和滑动窗口协议便是实现流水线传输

- 连续ARQ协议

  工作原理：发送方维持一个发送窗口，里面的分组可以连续发送，不需等待确认；接收方采用累计确认方式，只对按序到达的N个分组的最后一个发送确认，表示到该分组为止的所有分组已收到；发送方收到确认分组后，发送窗口向前滑动N个分组位置

  优缺点：易实现，且确认丢失不必重传；无法向发送方反映接收方已正确收到所有分组的信息，比如连续分组中第3个分组丢失，接收方对前两个发出确认，之后发送方对后三个重传，这就叫回退N，表示需退回重传已发送过的N个分组

- 滑动窗口协议
  
  1、窗口以字节为单位
  - 通知窗口(发送窗口、接收窗口) = 已发送未确认的 + 未发送的
  - 可用窗口 = 未发送的
  - 发送缓存 = 发送窗口 + 准备好的
  - 接收缓存 = 按序到达但未被应用程度读取的 + 接收窗口

  2、超时重传时间的设定采用自适应算法

    未超时重传(有效往返时间样本)，
      
      新RTTs = [(1 - a) * 旧RTTs + a * 新RTT, RTT(第一次)]

      新RTTd = [(1 - b) * 旧RTTd + b * | RTTs - 新RTT |, RTT/2(第一次)]

      RTO = RTTs + 4 * RTTd

    每超时重传一次(无效往返时间样本)，
        
      新RTO = 2 * 旧RTO
  
    其中，

    RTT表示报文某次往返时间

    a取值0.125

    RTTs表示平滑往返时间，加权平均RTT

    b取值0.25

    RTTd表示RTT偏差的加权平均值

    RTO表示超时重传时间
  
  3、*选择确认SACK

    实现"接收方收到无差错但未按序的报文段，发送方只重传缺少的数据，不重传已正确到达的数据"的效果

    原理：TCP首部添加SACK选项(占1个字节)及其占用字节数(占1个字节)，最多能提供4个缺少的字节块的边界信息(1个字节块有2个边界，1个边界占用4个字节，所以4个字节块占32字节)

- 牛刀小试：有相距1500KM的两机房A和B,现有100GB的数据需要通过一条FTP连接在100S的时间内从A传输到B.已知FTP连接建立在TCP协议之上,而TCP协议通过ACK来确认每个数据包是否正确传输.网络信号传输速度2*10^8 m/s.假设机房带宽足够高,那么A节点的发送缓冲区可以设置为最小多少?

  每秒需传输信息量：100GB / 100s = 1GB/s

  往返时间：1500km / (2*10^8m/s)*2 = 0.015s

  往返时间内需传输信息量，即最小缓冲区：1GB/s * 0.015s = 15MB

### TCP流量控制
- 含义：让发送方发送速率不要太快，要让接收方来得及接收
- 滑动窗口实现流量控制：发送窗口大小不超过接收窗口
- 存在问题
  
  - 死锁问题：当接收方接收窗口为0，而接收缓存部分释放时，向发送方发送了非零窗口通知但丢失了，此时发送方在等待非零通知，接收方在等待发送方数据，造成死锁
  
    TCP为每个连接设置一个持续计时器。当收到零窗口通知时发送方开启持续计时器，到达持续阈值时发送零窗口探测报文报，接收方确认该报文报后返回当前窗口，若窗口仍为0则重启持续计时器，否则即可解除死锁
  
  - 传输效率问题：本质是数据小导致传输效率低

    数据少且带宽小的场景下正常传输：Nagle算法，第一次先发第一个字节；确认后将发送缓存的所有数据一次发出，或缓存数据达到发送窗口一半大小发出，或缓存数据达到报文段的最大长度发出；后面的数据继续缓存，按上面规则一次发出，反复如此

    糊涂窗口综合症(当接收缓存已满，且应用进程一次只从缓存读取1字节的场景下正常传输)：接收方等待一段时间使接收窗口有一个最长报文段空间或占据一半的空闲空间，才发出确认报文；发送方也不要发送太小的报文段，把数据积累成最长报文段或达到接收缓存空间的一半大小

### TCP拥塞控制
- 拥塞：在某段时间，若对网络中某一资源(带宽、交换节点中的缓存和处理机)的需求超过了该资源所能提供的可用部分，网络性能就会变坏
- 拥塞控制的理解

  前提？网络能承受现有的网络负荷

  是什么？
  - **防止过多数据注入到网络中**，这样可以使网络中的路由器或链路不致过载
  - 流量控制是端问题，控制点对点的通信量，而拥塞控制**既有对端的控制，也有对网络的控制**
  - 是一个**全局性过程**，需要各部分保持平衡，绝不是局部优化就可以解决
  - 是一个**动态问题**，致使难以设计
- 拥塞原因
  
  在许多情况下，甚至正是拥塞控制机制本身成为引起网络性能恶化甚至发生死锁的原因
- 拥塞控制方法
  - 开环控制：事先将发生拥塞的因素考虑周到，一旦系统运行便不可修改
  - 闭环控制：基于反馈环路。**监测**网络系统(缺少缓存空间而丢弃的分组的百分数、平均队列长度、超时重传分组数、平均分组时延、分组时延标准差)，得知拥塞在何时何处发生；将拥塞发生信息**通知**给可采取行动的地方；**调整**网络系统运行
- 拥塞控制算法
  
  - 第一种算法：慢开始与拥塞避免
    
    cwnd <= ssthresh：使用慢开始，即cwnd从MSS开始逐渐增大，每经过一个传输轮次(从发送连续报文到收到最后一次确认的往返时间)，拥塞窗口就增大一倍
  
    cwnd >= ssthresh：使用拥塞避免，即每经过一个传输轮次，拥塞窗口增加1

    一出现拥塞，设置ssthresh为当前发送窗口一半，并重置cwnd=1，执行慢开始(乘法减小旧版，已废弃)，达到ssthresh则执行拥塞避免(此过程叫加法增大)

    其中，cwnd：拥塞窗口，发送窗口 = 拥塞窗口；ssthresh：慢开始门限，取值为[max(2, 出现拥塞时发送窗口的一半), 16(第一次)]
  
  - 第二种算法：快重传与快恢复

    快重传：接收方每收到一个失序的报文段后立即发出重复确认，让发送方尽早知道有报文段未到达对方，当发送方连续收到3个重复确认则立即重传对方尚未收到的报文段

    快恢复：当发送方连续收到3个重复确认，则设置ssthresh为当前发送窗口一半，并令cwnd=ssthresh，执行拥塞避免(乘法减小新版)
- 随机早期检测RED
  
  问题：网络层对传输层拥塞控制影响最大的策略是尾部丢弃，也即是队列满时丢弃后面的分组，导致超时重传，误以为拥塞，许多TCP连接同时进入拥塞控制的慢开始状态，称为全局同步

  解决：随即早期检测RED，是网络层针对传输层拥塞控制相应采取的一种策略。在可能的条件(不适于瞬时队列长度远超平均队列长度的情景)下尽量使尾部丢弃不发生，避免发生全局性的拥塞控制

  算法：

    Lav <= THmin，新到达的分组放入队列进行排队

    Lav >= THmax，新到达的分组丢弃

    THmin < Lav < THmax，以概率P将新到达的分组丢弃

    其中，

    Lav表示平均队列长度，公式为：新Lav = (1- g) * (旧Lav) + g * 当前队列长度样本

    THmin表示队列长度最小门限

    THmax表示队列长度最大门限，一般为THmin的2倍

    P表示分组丢弃概率，公式为：P = Ptemp / (1 - count * Ptemp)，其中count表示新到达的分组中有多少个进入队列，Ptemp表示过渡的分组丢弃概率，即 Ptemp = Pmax * (Lav - THmin) / (THmax - THmin)

### TCP连接管理
运输连接分连接建立、数据传送、连接释放三个阶段。

- 三次握手
  |          | 事件 | SYN | ACK | 序列号 | 确认号 |
  |--------- |-----|-----|-----|-------|-------|
  | 第一次握手 | 客户端发送SYN报文段到服务端，进入SYN-SENT状态 | 1 | 0 | x | |
  | 第二次握手 | 服务端收到SYN报文段后，发送SYN/ACK报文段给客户端，进入SYN_RCVD状态 | 1 | 1 | y | x+1 |
  | 第三次握手 | 客户端收到SYN/ACK报文段后，向服务端发送ACK报文段，客户端进入ESTABLISHED状态，服务端收到后也进入该状态 | 0 | 1 | x+1 | y+1 |

  | 状态       |   含义            |
  |--------|----------------------|
  | LISTEN | 收听状态，等待客户的连接请求 |
  | SYN-SENT | 同步已发送状态 |
  | SYN-RCVD | 同步收到状态，进入半连接 |
  | ESTABLISHED |	已建立连接状态，进入全连接 |

  > 注意：

  > 三次握手时，当全连接队列已满，服务端不会将该连接由SYN-RCVD变ESTABLISHED，只创建一个定时器，以固定间隔重传SYN/ACK报文段，当到达系统设定的重传阖值时服务端丢弃处于半连接队列里的SYN报文

  > 第三次握手时，有携带数据则消耗序号，否则不消耗序号

  > 需要第三次握手是为了防止失效的连接请求报文段(因网络延迟致使连接释放后才收到)突然又传到服务端，导致建立无用连接的情景

- 四次挥手
  |           | 事件 | FIN | ACK | 序列号 | 确认号 |
  |-----------|-----|-----|-----|-------|--------|
  | 第一次挥手 | 客户端发送连接释放报文段，并停止发送数据，进入FIN-WAIT1状态 | 1 | 0 | u |  |
  | 第二次挥手 | 服务端收到FIN报文段后，发送确认报文段，进入CLOSE-WAIT状态，客户端收到确认后进入FIN-WAIT2状态。此时连接处于半关闭状态 | 0 | 1 | v | u+1 |
  | 第三次挥手 | 服务端发送给客户端的数据完毕后，发送FIN/ACK报文段，进入LAST-ACK状态 | 1 | 1 | w | u+1 |
  | 第四次挥手 | 客户端收到FIN/ACK报文段后，发送确认报文给服务端，此时进入TIME-WAIT状态，服务端收到确认报文后则进入CLOSED状态。而客户端要等待2MSL后才进入CLOSED状态 | 0 | 1 | u+1 | w+1 |

  | 状态       |   含义            |
  |--------|----------------------|
  | FIN-WAIT-1 |	终止等待1状态，等待服务端确认 |
  | CLOSE-WAIT |	关闭等待状态，通知服务端高层 |
  | FIN-WAIT-2 |	终止等待2状态，等待服务端释放 |
  | LAST-ACK |	最后确认状态，等待客户端确认 |
  | TIME-WAIT |	时间等待状态 |
  | CLOSED |	没有任何连接状态 |

  > 注意：

  > FIN报文段不携带数据也会消耗一个序号

  > 为什么建立连接是三次握手，而关闭连接却是四次握手？
  
    当收到客户端连接释放报文通知时只表示客户端没有数据发送给服务器了，而**服务器可能还有数据需要传输给客户端**，之后才能关闭连接，所以ACK报文和FIN报文需要分开发送
  
  > 进行四次挥手时，为什么TIME_WAIT状态还需等2MSL后才返回到CLOSED状态？

    MSL表示最长报文段寿命，一般为2min，则2MSL表示4min

    一是保证客户端发送的最后一个ACK报文能够到达服务端。若Client直接CLOSED，由于网络原因，导致Server没有收到Client最后回复的ACK，就会在超时之后继续发送FIN，此时Client已CLOSED，找不到与重发的FIN对应的连接，最后Server收到RST，而不是ACK，Server以为是连接错误把问题报告给高层。所以是为了**重发可能丢失的ACK报文**
  
    二是防止已失效的报文段(因网络延迟致使连接释放后才收到)出现在新连接中。若Client直接进入CLOSED状态，且又再向Server发起一个新连接，由于新连接和老连接的端口号可能相同，若前一次连接的某些数据滞留在网络中，在建立新连接之后才到达Server，则TCP协议认为延迟的数据是属于新连接的，这样和真正的新连接的数据包发生混淆。所以是为了**保证这次连接的失效报文段从网络中消失**

### TCP性能调参
![](/network/TCP性能调参.png)

![](/network/优化三次握手对应的参数.png)

![](/network/优化四次挥手对应的参数.png)

![](/network/数据传输对应的参数.png)

[参考](https://mp.weixin.qq.com/s/cPHi-gjuZbMFFw4v0oosvw)

### 扩展
#### 服务端挂掉，TCP连接是否还在
- 如果「服务端挂掉」指的是「服务端进程崩溃」，服务端的进程在发生崩溃的时候，内核会发送 FIN 报文，与客户端进行四次挥手
- 如果「服务端挂掉」指的是「服务端主机宕机」，那么是不会发生四次挥手的，具体后续会发生什么？还要看客户端会不会发送数据？
  - 如果客户端会发送数据，由于服务端已经不存在，客户端的数据报文会超时重传，当重传总间隔时长达到一定阈值（内核会根据 tcp_retries2 设置的值计算出一个阈值）后，会断开 TCP 连接；
  - 如果客户端一直不会发送数据，再看客户端有没有开启 TCP keepalive 机制？
    - 如果有开启，客户端在一段时间没有进行数据交互时，会触发 TCP keepalive 机制，探测对方是否存在，如果探测到对方已经消亡，则会断开自身的 TCP 连接；
    - 如果没有开启，客户端的 TCP 连接会一直存在，并且一直保持在 ESTABLISHED 状态。

#### 连接超时与请求超时
- 连接超时：由于TCP连接是可复用的，指整个长连接的超时时间
- 请求超时：字面意思，单个请求的超时时间，程序中我们一般设置的是这个

## 应用层
### 网络服务
#### 域名系统
- 由来：解决IP地址难记问题，负责将人们便于记忆的域名转换为IP地址。它们是这样的关系，IP地址: 域名 = N: 1
- 本质：联机分布式数据库系统(为了提高可靠性，使用主从复制、读写分离；为了提高查询效率，使用高速缓存)，基于UDP实现

- 域名：由标号序列组成，标号间使用.隔开，标号由不超过63个字符的字母、数字、短横杆组成。总大小不超过255个字符，标号从左到右，域的级别逐渐升高，分别称为四级域名、三级域名、二级域名、顶级域名
- 按域名服务器的作用分为本地域名服务器(默认域名服务器)、权限域名服务器、顶级域名服务器、根域名服务器
- 域名解析原理：主机向本地域名服务器发起递归查询，本地域名服务器再发起递归查询(按本地域名服务器、根域名服务器、顶级域名服务器、权限域名服务器的顺序查询)或迭代查询(本地域名服务器负责查询，根、顶级域名服务器只告知下步该找哪个下级域名服务器进行查询，最后从指定权限域名服务器查找)，一查到立即返回

- 设备如何获取DNS地址？通过动态主机配置协议(DHCP)，当一台设备连到路由器之后，路由器通过DHCP给它分配一个IP地址，并告诉其DNS服务器
- DNS解析的结果类型
  - A记录，表示结果是一个IP地址  
  - CNAME记录，表示结果是另外一个域名

#### 万维网
- 一个大规模的、联机式的信息储存所，简称Web
- 一个分布式的超媒体系统
  
  标志文档：统一资源定位符URL

  实现链接：超文本传输协议HTTP

    HTTP面向事务(要么成功，要么失败)、无连接(没有HTTP连接)、无状态(相同输入相同输出)
    
    面试常问从浏览器输入url到页面展示发生了什么？DNS解析 -> 建立TCP连接 -> 发送请求 -> 服务器响应 -> 浏览器渲染

  编写文档：超文本标记语言HTML
  
  方便查找信息：两种不同的信息搜索引擎，即全文检索搜索引擎和分类目录搜索引擎

  > 个人理解：元搜索引擎属于全文检索搜索引擎，分类目录搜索引擎其实就是站内搜索引擎

#### 电子邮件
- 组成  
  - 用户代理：发送方和接收方
  - 邮件服务器：发送方邮件服务器(只支持邮件发送协议)和接收方邮件服务器(支持邮件发送协议和读取协议)
  - 邮件发送协议如SMTP和邮件读取协议如POP3、IMAP

- 简单邮件传送协议SMTP
  - 连接建立：建立TCP连接后，接收方发送`220 Service ready`，发送方发送`HELO`命令，接收方发送`250 OK`
  - 邮件传送：发送方发送`MAIL`命令，接收方发送`250 OK`；接着发送多个`RCPT`命令，接收方发送`250 OK`；之后发送多个`DATA`命令，接收方发送`354 Start mail input;end with <CRLF>.<CRLF>`；最后发送`<CRLF>.<CRLF>`，接收方发送`250 OK`
  - 连接释放：发送方发送`QUIT`命令，接收方发送`221（服务关闭）`
  
  > SMTP不支持在客户服务两端中间再使用邮件服务器，只能直连
  > ESMTP是SMTP升级版，更安全、更快，建立连接时发送的是`EHELO`

- 邮件协议POP3

  特点：用户代理从邮件服务器读取邮件后，服务器会自动删除邮件

  > 网际报文存取协议IMAP：用于邮件读取，是一个联机协议(需上网)
  
- 工作过程

  发送方用户代理--[SMTP推]-->发送方邮件服务器--[SMTP推]->接收方邮件服务器--[POP3拉]-->接收方用户代理

- 基于万维网的电子邮件工作过程

  发送方用户代理--[HTTP推]-->发送方邮件服务器--[SMTP推]->接收方邮件服务器--[HTTP拉]-->接收方用户代理

#### 文件共享
- 文件共享协议分类
  
  复制整个文件：读写文件副本，同步副本到原节点，如FTP、TFTP
  
  联机访问：多个程序通过操作系统对一个文件进行"透明"存取，像本地操作一样，如网络文件系统NFS

- 初识FTP
  
  特点：实现跨系统的文件传输；基于TCP；客户端与服务端是多对一

  原理：先建立控制连接(端口21)，再创建数据连接(端口20)，使用两个独立连接使协议更简单和易实现

- 初识TFTP
  
  与FTP不同的是，基于UDP，需实现差错纠正；只支持文件传输，不支持文件交互；代码占用内存小

  使用端口为69

- P2P模式
  - 解决集中式媒体服务器访问瓶颈问题
  - 工作方式演变过程

    集中性目录服务器，可靠性差
    
    非集中性目录服务器，有限范围的洪泛查询
    
    eRule：服务器只保存用户信息，采用分散定位和分散传输技术（文件分块 + 多源文件传输协议MFTP）实现并行下载
    
    BT：在相邻对等方之间使用按资源最稀罕优先的算法请求文件块，按速率最快优先的算法发送文件块
  - P2P所有主机下载资源F的下限时间

    Tp2p >= max(F/us, F/dmin, NF/uT)

    F：资源大小，us：服务器上传速率，dmin：主机最慢下载速率，N：下载主机数，uT：所有主机上传速率之和

### 其他应用层协议
#### 远程终端协议Telnet
- 基于TCP，服务"透明"，又叫终端仿真协议
- 跨系统，基于网络虚拟终端NVT抹去了差异性

#### 动态主机配置协议DHCP
- 介绍：实现即插即用连网，自动为新加入主机分配IP地址。基于UDP，一般使用路由器作DHCP中继代理，使广播变单播，向DHCP服务器发起发现报文
- 工作流程
  - 1、服务器被动打开UDP端口67，等待客户端的发现报文
  - 2、客户端从UP端口68发送**发现报文**，其中源地址0.0.0.0，目的地址255.255.255.255
  - 3、服务器收到发现报文后，发送**提供报文**（有多个）
  - 4、客户端从几个服务器中选择其一，并向其发送**请求报文**
  - 5、被选择的服务器收到请求报文后，发送**确认报文**，此时客户端可以使用提供报文中的IP地址，并根据服务器提供的租用期T设置两个计时器T1和T2，超时时间分别为0.5T和0.875T
  - 6、到达T1，客户端发送**租用期更新请求报文**
  - 7、服务端收到更新请求报文后，发送**确认报文**或**否认报文**或者不响应，是前者则重置计时器，是后者则停止使用IP，重新申请，即回到步骤2，是第三者则到达T2，客户端重新发送租用期更新请求报文，即回到步骤6
  - 8、客户端发送释放报文，提前终止服务器提供的租用期

#### 简单网络管理协议SNMP
- 网络管理模型的主要构件
  - 管理站，安装有运行SNMP客户端程序的管理程序(端口162)
  - 被管设备，安装有运行SNMP服务端程序的网络管理代理程序，或叫代理(端口161)
  - 网络管理协议，或叫网管协议，如SNMP(基于UDP)
- 网络管理

  定义：对硬件、软件和人力的使用、综合与协调，以便对网络资源进行监视、测试、配置、分析、评价和控制，这样就能以合理的价格满足网络的一些需求，如实时运行性能、服务质量等

  组成
  - 管理信息结构SMI：定义了被管对象的命名(通过对象命名树)、数据类型(分简单类型和结构化类型)，以及把对象和对象的值进行编码的规则(TLV，T表示数据类型，L表示值的长度，V表示值)
  - 管理信息库MIB：存储被管对象集合的信息，如命名、数据类型、值
  - SNMP：定义管理站和代理之间交换的分组格式。提供读(检测各被管对象的状况)、写(改变各被管对象的状况)两种操作，通过探询操作实现，即允许不经过询问就向被管设备定时发送探询信息(陷阱)，当代理检测到事件发生，则向管理站报告达到阈值(表示该事件严重)的事件，与陷阱信息相关

