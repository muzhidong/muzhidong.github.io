本篇介绍浏览器相关知识，先了解浏览器有哪些进程，再认识各大浏览器使用的渲染引擎和脚本引擎，接着介绍浏览器的事件循环和安全策略。

## 浏览器进程
- 主进程(负责协调和主控)

  ![](/browser/进程间通信.png)

  具体负责各页面管理，创建和销毁其他进程；将从渲染进程得到的内存中Bitmap，绘制到用户界面上。包括以下线程：

  UI线程：控制浏览器上的按钮如前进、后退及输入框
  
  网络线程：处理网络请求。在解析HTML时可能会遇到到图片、CSS、JavaScript脚本等资源，主线程会逐一发请求获取。为了提升效率，浏览器会运行预加载扫描程序，如果HTML中存在img、link等标签会把这些请求传递给主进程的网络线程进行资源下载，而不用等到解析

  存储线程：控制文件等的访问

- GPU进程(最多一个，专用于图形处理，如3D绘制)

- 渲染进程(Renderer进程/浏览器内核，包含多个线程)

  主线程(渲染线程)：负责页面渲染，通知JS线程

  合成线程

  JS引擎线程：负责执行JS脚本，与渲染线程互斥

  事件触发线程：控制事件循环。当事件符合触发条件时，会把事件添加到待处理队列，等待JS引擎处理

  定时触发器线程：计时并触发定时。当计时完毕，添加到事件队列中，等待JS引擎空闲后执行

  异步http请求线程：新开一个线程请求

- 第三方插件进程(每个类型对应一个进程)

  提供[入门插件v3开发示例](https://github.com/muzhidong/chrome-plugin-demo)

> 浏览器进程模式
>  - Process-per-site-instance：default，同一个site-instance(相同的主域名和协议，且通过`window.open`或`<a target='_blank'>`联系)使用一个进程
>  - Process-per-site：同一个site(相同的主域名和协议)使用一个进程
>  - Process-per-tab：每个tab使用一个进程
>  - Single process：所有tab共用一个进程

## 浏览器引擎
有渲染引擎和脚本引擎。

| 浏览器 | 渲染引擎/排版引擎/内核 | 脚本引擎 |
|-------|---------|----------|
| Chrome | Blink | V8 |
| Safari | WebKit | JavaScriptCore | 
| Edge | 旧版EdgeHTML/新版Blink | 旧版Chakra/新版V8 |
| FireFox | Gecko | SpiderMonkey |
| Opera | Blink | 旧版Carakan/新版V8 | 
| IE | Trident | Chakra |

## 浏览器事件循环
### JS在浏览器中的特点
- 单线程：JS是为浏览器而设计的脚本语言，主要用在用户交互，操作DOM上。基于事件驱动决定它只能是单线程，否则带来很复杂的同步问题。比如调用`alert`会阻塞`setInterval`计时
- 异步：提供回调、Promise、Generator、Async、worker等异步手段

### 浏览器为JS运行划分的内存空间
- 栈：函数调用时生成一个栈帧
- 堆：对象分配时用一块非结构化的内存区域表示
- 队列：一个待处理的事件队列（具有优先级的队列）。每个事件关联着一个处理该事件的函数，当事件触发时，此事件处理函数会先入队，被调用时再入栈，直至执行结束从栈离开。队列便是进行上述周而复始的工作

### 事件循环
- 目的：为了能在单线程中支持非阻塞异步
- 工作原理

  1、**先执行优先级最高的主代码，过程中若遇到异步操作则由相应线程进行监听，等待放入队列。当执行栈空闲时，从队列中取出一个个触发的事件执行**

  ![](/browser/事件循环示例图解.png)

  2、**执行事件队列中的任务时，先检查是否有微任务，有则执行，之后渲染，进行下一次循环，执行下个宏任务。接着在宏任务中有微任务，先执行微任务，渲染后再执行当中的宏任务，作为下个宏任务，层层递归(不会停)**。示意如下，

  ![](/browser/事件队列任务优先级.png)

  事件任务分宏任务和微任务

  宏任务有主代码、定时器、事件回调如网络、交互、通信等；微任务有Promise.then和catch、await后的代码、各种Observer回调
  
  微任务 > 宏任务，宏任务放在下一帧执行
  
  宏任务也分不同优先级，如用户交互 > 网络事件，让用户感觉更加流程

> 每次循环都会渲染吗？不一定，根据屏幕刷新率(帧率低)、页面性能(浏览器上下文不可见)、页面是否在后台运行(**浏览器判断更新渲染不会带来视觉上的改变**、帧动画回调为空)来共同决定

- 应用
  ```js
  // 如何避免栈溢出（时间换空间）
  const list = getHugeList()
  const fun = function(){
    const item = list.pop()
    if(item) {
      // fun()
      // 利用事件循环，防止栈溢出
      setTimeout(fun, 0)
    }
  }
  fun()
  ```

## 浏览器安全策略
### 同源策略
同源指协议、主机地址、端口号都相同。只要其中一个不同，则不同源
- cookie、localStorage、sessionStorage、indexDB仅同源共享，本地则端口无限制
- dom和js仅同源共享
- ajax和fetch默认仅同源请求：浏览器不阻止向另一个域名发送请求，但拒绝来自不同源的响应
> 注：link、script、img、iframe的href或src属性不受同源限制

### iframe沙箱
对常规iframe表现行为的扩展，能让顶级页面对其嵌入的子页面及这些子页面的子资源设置一些额外的限制。通过iframe属性sandbox进行限制，部分取值如下，
- allow-scripts：是否允许执行js脚本，没有则不允许
- allow-forms：是否允许使用form表单，没有则不允许
- allow-top-navigation：是否允许嵌入子页面控制顶级窗口的地址跳转，没有则不允许
- allow-same-origin：是否允许访问同源数据，没有则不允许

### http资源在https域名下不能被访问
浏览器默认不允许在https里引用http资源，比如引入http请求的js文件会被block、通过ajax请求http资源也会被block。Chrome v21后，在https页面嵌入非SSL的Flash资源也会被屏蔽，只留下一句console报告。解决方法：
- 引用资源不指定具体协议，自适配。也就是说当前为https页面会变为https资源，如果是http页面变为http资源
- 植入代码`<meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">`，表示自动将http不安全请求升级为https

## 彩蛋
- 浏览器支持的最大并行TCP连接数是多少?
  
  在HTTP/1.1协议中，最多支持6个同域下的并行TCP连接；但在HTTP/2协议中，由于多路复用特性，可以避开并行TCP连接数限制。
