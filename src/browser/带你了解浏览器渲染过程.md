# 渲染过程
- 渲染是什么？
  
  在图形学上，渲染指把模型变成位图的过程。把每一个元素对应的盒变成位图，这里的元素包括HTML元素和伪元素，一个元素可能对应多个盒（比如inline元素，可能会分成多行）。每一个盒对应着一张位图。渲染可分两大类：图形和文字。都需要底层支持，即图形库(Android skia，window GDI)、字体库(Freetype)

- 浏览器渲染过程
  
  浏览器渲染过程专业版
  ![](/browser/render_engine/浏览器渲染过程专业版.jpg)

  浏览器渲染过程白话版
  ![](/browser/render_engine/浏览器渲染过程白话版.jpg)

  线程角度看浏览器渲染过程
  ![](/browser/render_engine/线程角度看浏览器渲染过程.jpg)

## 1、构建DOM
HTML文档逐步从字节、字符、语义块、节点，最后形成DOM。
![](/browser/render_engine/构建DOM_1.jpg)

具体如下，
- 字符转换：浏览器从磁盘或网络读取HTML原始字节，并根据文件编码转换成字符
- token化：浏览器将字符串转换(状态机)成W3C标准规定的各种token，每个token具有特殊含义和一组规则
  ![](/browser/render_engine/构建DOM_2.jpg)
- 词法分析：将token转换成定义其属性和规则的对象
- 构建DOM：由于HTML标记定义不同标记之间关系，对所有对象做链接(栈实现开闭标签配对)，形成一个树结构
  ![](/browser/render_engine/构建DOM_3.jpg)

## 2、执行JS
依序执行resize\scroll\媒体查询支持变化的特殊事件回调、requestAnimationFrame帧回调、宏任务、微任务

> 浏览器对事件的优化：
>  
> 一般屏幕帧率是60fps，但是一些连续性事件的触发频率超过了这个数值，比如wheel、mousemove、touchmove，假如每一次触发事件都将事件发送到主线程处理，由于屏幕的刷新速率相对较低，使主线程触发过量的命中测试以及JS代码，性能产生不必要的损耗。为此，浏览器会合并这些连续性事件，延迟到下一帧执行，并在requestAnimationFrame之前

## 3、构建CSS OM，并结合DOM生成渲染树
- CSS OM由CSS文档转换而成，过程类似构建DOM。其中的样式计算主要分以下两步：
  - 创建一套匹配的样式选择器
  - 为匹配的样式选择器计算具体的样式规则

  > 为什么CSS OM是树结构？
  > 
  > 因为页面上的任何节点对象计算最后一组样式时，浏览器都会先从适用于该节点的最通用规则开始，然后应用更具体的规则以递归的方式改变计算的样式

- DOM和CSS OM结合，生成渲染树
  
  从DOM树根节点开始遍历每个可见节点(不可见节点或通过CSS隐藏的节点都会被忽略)，每遍历一个可见节点，从右到左开始匹配选择器，即从CSS OM树的子节点开始，往父节点匹配，一旦找到匹配的，则应用其规则到DOM节点上

## 4、布局Layout
目前只知道哪些节点是可见的及其计算样式，还需计算每个可见元素在设备视口内的坐标位置和大小。从渲染树的根节点开始遍历，输出一个盒模型，精确捕获每个元素在视口内的确切位置和尺寸

> 页面各个部分可能被绘制到不同图层上。触发创建独立图层的任一条件：
>
>  The layer has `3D or perspective transform` CSS properties.
>
>  The layer is used by `<video>` element using accelerated video decoding.
>
>  The layer is used by a `<canvas>` element with a 3D context or accelerated 2D context.
>
>  The layer is used for a composited plugin, e.g. Flash or Silverlight.
>
>  The layer uses a `CSS animation for its opacity or uses an animated webkit transform`.
>
>  The layer uses accelerated `CSS filters`.
>
>  The layer `has a descendant that is a compositing layer`.
>
>  The layer `has a sibling with a lower z-index which has a compositing layer` (in other words the layer is rendered on top of a composited layer)
>
>  元素可滚动
>  
>  应用`mask-image`
>  
>  will-change值为`opacity`，或`transform的`
>
>  transition应用属性为`transform`

触发回流reflow(重布局/重排)的属性如下：

  display

  position
  top
  bottom
  left
  right

  float
  clear

  width
  height
  min-height
  border
  border-width
  padding
  margin

  text-align
  vertical-align
  line-height
  white-space

  font-weight
  font-family
  font-size

  overflow

## 5、绘制Paint
生成一系列绘画记录，按背景、文本、边框和阴影的顺序记录各元素绘制的先后顺序。因此背景、文本、边框和阴影的改变会影响绘制的先后顺序

触发重绘repaint的属性如下：

  border

  color
  text-decoration

  background

  border-radius
  box-shadow

  visibility

  outline

## 6、合成Composite
图层提交到`渲染进程的Compositor线程`，对它们进行rasterization(光栅化，将每一图层的信息转换为位图)，若满足GPU加速(硬件渲染)的条件就提交给GPU进程，否则直接转换为一张图片(合成帧)

  在这需要介绍两种浏览器渲染：
  
  - 软件渲染：绘制工作由CPU完成。如果页面的某一元素发生更新，WebKit首先计算需要更新的区域，然后只绘制同这些区域有交集的RenderObject节点。如果更新区域跟某个RenderLayer节点有交集，WebKit就会继续查找RenderLayer树中包含的RenderObject子树中的特定的一个或一些节点，而不是重新绘制整个RenderLayer对应的RenderObject子树。这个过程也被称之为CPU缓存机制
  
  - 硬件渲染：绘制工作由GPU完成。首先，WebKit依据指定条件决定将哪些RenderLayer组合在一起，形成一个新层(再合成的原因：减少内存使用量；合并后GPU会尽量减少元素发生更新带来的重排重绘性能和处理上的困难)并缓存在GPU，这些新层称为合成层，其中对于一个RenderLayer，如果它不会形成一个合成层，那么就使用它父亲所使用的合成层，直至追溯到document。最后，`GPU进程的Compositor线程`将所有的合成层转换为一张图片(合成帧)。每当有更新时，GPU只需对要更新的RenderLayer进行相应变换，提交到`GPU进程的Compositor线程`重新生成，不必回流、重绘

> 位图是在内存里建立一张二维表格，把一张图片的每个像素对应的颜色保存进去。位图信息是DOM树中占据内存最多的信息，做内存优化时，主要就是考虑这一部分。

> 合成器线程是如何将多个图层或合成层合并在一个页面上？
>
> 它会收集图块上绘画四边形信息构建一个合成帧。其中，绘画四边形draw quads，包含图块在内存的位置、图层合成后图块在页面的位置等信息；合成帧compositor frame，代表页面一个帧的内容的绘制四边形集合。

> 合成器线程如何接收事件？
> 
> 举例，如果页面绑定了页面滚动事件，合成器线程会等待主线程进行事件处理后才会创建组合帧。

> 合成器线程是如何判断这个事件是否需要路由给主线程处理呢？
> 
> 当页面合成时，合成器线程会标记页面中绑定有事件处理器的区域为非快速滚动区域，如果事件发生在这些存在标注的区域，合成器线程会把事件信息发送给主线程，等待主线程进行事件处理，如果事件不是发生在这些区域，合成器线程则会直接合成新的帧而不用等到主线程的响应。
>
> 当使用委托进行事件绑定，会使标记范围变大，这时可以在绑定事件时传递第三参数`{ passive: true }`，保证在硬件渲染的非快速滚动区域中正常绑定事件，至于软件渲染的快速滚动区域，合成器线程无需等待主线程进行事件处理，直接合成新帧。这也说明不是所有事件处理都需提交给主线程，比如纯滚动不需执行JS


