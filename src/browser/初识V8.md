## 编译型语言与解释型语言的区别
- 编译型语言运行前编译源代码，运行时直接使用编译后的结果
- 解释型语言运行时编译源代码，运行时的速度要慢于编译型语言

![](/browser/V8/编译型语言与解释型语言的代码执行过程.png)

## AOT与JIT
- AOT（静态编译）
  
  Ahead of time，提前编译，指在程序执行前全部被翻译为机器码。它把高级语言源程序作为输入，进行翻译转换，产生出机器语言的目标程序，然后再让计算机去执行这个目标程序，得到计算结果

- JIT（动态编译）
  
  Just-in-time，即时编译，边翻译边运行，不产生目标程序。它将源语言书写的源程序作为输入，解释一句后就提交计算机执行一句，并不形成目标程序
  
  如在终端上打一条命令或语句，解释程序就立即将此语句解释成一条或几条指令并提交硬件立即执行且将执行结果反映到终端，从终端把命令打入后，就能立即得到计算结果

- AOT和JIT的比较
  
  AOT：运行前全部编译好，不用的也编译了，牺牲了平台无关性和代码质量，因为它们不能利用程序的动态行为，也不具有关于加载的类或类层次结构的信息。但是避免 JIT运行时性能或内存消耗，或者避免解释程序的早期性能开销

  JIT：运行时动态编译，可以只编译常使用的方法（热方法），提高效率；代码结构好能提高程序执行速度；运行时进行本地代码编译而不是在程序运行前编译，保证了可移植性

## V8引擎
Google开源的C++实现的JS引擎和WebAssembly引擎，可应用于Chrome和NodeJS，负责将JS转换为机器可识别的指令（类似JVM一类东西）

### 组成
- 解析器Parser：将源代码解析成AST
- 解释器Ignition：将AST转换成字节码并执行，同时标记热点代码
- 编译器TurboFan：将热点代码编译成机器码并执行
- 垃圾回收器Orinoco：回收内存空间

> 学习链接：https://zhuanlan.zhihu.com/p/519161945

#### 工作流程
![](/browser/V8/V8工作流程(2017).png)

- 编译结果为直接解释的字节码和优化后的机器码
  
  ![](/browser/V8/编译流水线两种结果.jpg)

#### 解析器
分词法分析和语法分析两个阶段
- 词法分析也称分词，将字符串形式的代码转换为token序列，其中token是字符串，是构成源代码的最小单位。示例如下，
  ![](/browser/V8/词法分析.png)
- 语法分析负责将词法分析产生的token按照给定形式的文法转换为AST
  ![](/browser/V8/语法分析.png)

> 如果JavaScript代码在执行前都要完全经过解析才能执行，那可能会面临以下问题：
> - 代码执行时间变长：一次性解析所有代码会增加代码的运行时间
> - 消耗更多内存：解析完的AST以及根据AST编译后的字节码都会存放在内存中，会占用更多内存空间
> - 占用磁盘空间：编译后的代码会缓存在磁盘上，占用磁盘空间
> 所以，V8引擎使用了延迟解析：在解析过程中，对于不是立即执行的函数，只进行预解析；只有当函数调用时，才对函数进行全量解析。进行预解析时，只验证函数语法是否有效、解析函数声明、确定函数作用域，不生成AST

[在线AST生成器](https://astexplorer.net/)

#### 解释器
- 流程
  ![](/browser/V8/解释器.png)

  ![](/browser/V8/解释器内部流程.jpg)

  依次经过
  - 字节码生成器：根据AST生成对应的C++函数
  - 寄存器优化器：减少非必要的寄存器加载和存储，合并公共的字节码转化为单个字节码然后一次性执行所有操作
  - 窥孔优化器
  - 消除死代码：减少字节码体积，Dead-code是不会运行到的代码
  - 字节码数组写入器：将字节码传回给解释器

- 示例
  
  ![](/browser/V8/编译为字节码示例.jpg)
  
  可以发现，指令是从右到左运算

- 有两种编译模式，产生两种结果：
  - 直接解释：负责将AST转换成字节码。字节码是介于AST和机器码的一种代码，是对机器码的一个抽象描述，相对于机器码而言，它的代码量更小，可以减少内存消耗
  - 优化后的机器码：部分字节码逐条解释执行为机器码

#### 编译器
根据字节码和热点函数反馈类型，生成优化后的机器码。热点代码（重复执行的代码，运行次数超过某个阈值就被标记为热代码）会被优化，编译为机器码进行存储。下次执行相同代码时，直接执行机器码，提升代码执行效率。当代码不再是热点代码时，编译器会执行去优化过程，将优化编译后的机器码还原为字节码，把代码的执行权利交回给解释器

![](/browser/V8/编译器.png)

> 字节码配合解释器和编译器的技术其实是即时编译JIT

#### 垃圾回收器
- 引用计数法

  初代算法。若没有其他对象引用指向某一对象，则回收该对象。在循环引用问题上无法解决

- 分代回收法

  现今算法。提供主、副两个垃圾回收器

  副垃圾回收器：负责新⽣代(对象生存时间短，区容量小)的垃圾回收。分两个from和to空间，即对象区和空闲区，对象区满后进行垃圾回收即做标记，之后把复制存活对象到空闲区，并将两个区反转，称为`Scavenge`算法
  
  主垃圾回收器：负责⽼⽣代(对象生存时间长，区容量大)的垃圾回收。经过两次垃圾回收依然存活的对象会移动到到⽼⽣代中，起初采用标记清除法，后改用标记整理法

  - 标记清除法

    1、标记阶段：从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据

      优化全停顿(stop-the-world)标记（只适于标记过程中应用程序暂停的情形） 
    
      - 增量标记（闲置时间进行GC，实现在主线程中任务和GC及时切换运行）

        为了降低老生代的垃圾回收而造成的卡顿，V8将标记过程分为一个个的子标记过程，同时让垃圾回收标记和JavaScript应用逻辑交替进行，直到标记阶段完成，这个算法称为增量标记算法

        使用增量标记算法可以把一个完整的垃圾回收任务拆分为很多小的任务，这些小的任务执行时间比较短，可以穿插在其他的 JavaScript 任务中间执行，这样当执行代码时，就不会让用户因为垃圾回收任务而感受到页面的卡顿了

        ![](/browser/V8/使用增量标记前.png)

        ![](/browser/V8/使用增量标记后.png)
    
      - 平行标记和并发标记（引入工作线程，提高吞吐量和暂停时间）
        
        平行标记：发生在主线程和工作线程上，应用程序在整个平行标记阶段暂停，相当于stop-the-world标记的多线程版本

        ![](/browser/V8/平行标记.jpg)
        
        为了平行标记对象图，需要确保GC数据结构是线程安全的，并找到一种方法有效地在线程之间共享标记工作。线程只能从对象图中读取并且不会被更改，对象的标记位点和标记工作表必须支持读取和写入的访问

        ![](/browser/V8/平行标记涉及的数据结构和数据流向.jpg)

        并发标记：发生在工作线程上，当并发标记进行时，应用程序可以继续执行

        ![](/browser/V8/并发标记.jpg)

        数据竞争来源很多，如对象分配、写入一个对象字段、对象布局更改、从snapshot中反序列化、Materialization during deoptimization of a function、在新一代GC中疏离、代码修补。主线程需要与工作线程同步，同步的成本和复杂程度取决于操作。

      增量标记、平行标记、并发标记的结合：
      ![](/browser/V8/增量标记、平行标记、并发标记的结合.jpg)

      > 并发与并行的区别：
      >  - concurrent并发：交替执行，多个任务在同一时刻由单个CPU核心轮流处理。提高CPU利用率，提升系统响应速度
      >  - parallel并行：同时执行，多个任务在同一时刻由不同CPU核心处理。最大化硬件性能，缩短多个任务的总执行时间
    
    2、清除阶段：主垃圾回收器会直接将标记为垃圾的数据清理掉

    ![](/browser/V8/标记清除法.png)

  - 标记整理法：对⼀块内存多次执⾏标记清除算法后，会产⽣⼤量不连续的内存碎⽚。⽽碎⽚过多会导致⼤对象⽆法分配到⾜够的连续内存，于是⼜引⼊了另外⼀种算法——标记整理
    
    过程与标记清除算法⼀样，先标记可回收对象，但后续步骤不是直接对可回收对象进⾏清理，⽽是让所有存活的对象都向⼀端移动，然后直接清理掉这⼀端之外的内存

    ![](/browser/V8/标记整理法.png)

### 源码
#### 属性访问
- 将对象的值和shape分开存储，使具有相同形状的对象共用同个shape
  ```js
  const a = {
    x: 1,
    y: 2
  }
  const b = {
    x: 3,
    y: 4
  }
  // 优化前：Object中的每个属性持有value\writeable\enumerable\configurable等
  // Object 'x' 'y'
  // Object 'x' 'y'
  // 优化后：JSObject只存储值，Shape存储offset\writeable\enumerable\configurable等，offset表示JSObject内部值的偏移量，便于查找值
  // JSObject 1 2
  // JSObject 3 4
  // Shape 'x' 'y'
  ```

- 每个Shape只需要知道它引入的新属性，它会与其之前的Shape相连。shape相连形成transition树结构
  ```js
  // 不需要为每个Shape存储完整的属性表
  const c = {}
  c.i = 5
  c.j = 6

  // 与c共用空的shape
  const d = {}
  d.m = 7
  d.n = 8

  // 不与c共用有i的shape，而是直接新建有i的shape
  const e = {
    i: 9
  }
  ```

以上都是为Inline Caches(ICs)服务。如果JavaScript引擎看到一个对象的shape之前被ICs记录过，则它不再需要接触属性信息，而是跳过昂贵的属性信息查找，这比每次查找属性要快得多
```js
function getX(o) {
  return o.x
}
// 转换为如下指令，其中第二行表示从第一个参数arg1加载属性'x'值，并将其存储到地址loc0中，而args1指向shape，x的值存储在偏移量0处
// JSFunction 'getX'
// get_by_id loc0, args1, x
// return loc0
```

上述优化对数组同样适用

提升性能的实用JavaScript编码技巧：
- 始终以相同的方式初始化对象，以确保它们不会走向不同的shape方向(使用相同方式初始化对象)
- 不要混淆数组元素的属性特性，以确保可以高效地存储和操作它们(**避免在数组索引上使用Object.defineProperty**，改变writeable\enumerable\configurable等，它会使性能低效)

#### 整数范围
V8使用最低有效位将JS值标记为对象或者SMI(小整数，因为它是31位)。如果最低有效位是1，则是对象，如果是0，则是SMI
```c
// 在64位计算机上kSmiValueSize被定义为32
const int kSmiMinValue = (static_cast<unsigned int>(-1)) << (kSmiValueSize — 1);           
            //  = (111...111)_2 << (32-1)              
            //  = (111...111)_2 << 31             
            //  = (11...1100...00)_2  // 31个零            
            //  = -2^31
const int kSmiMaxValue = -(kSmiMinValue + 1);
// 在64位平台上V8对Smis定义的范围是[-2³¹，2³¹-1]
```
> 当一个二进制表示的数值超过31位，V8会对其"装箱"，将它转化为浮点数，并且创建一个新对象存储它

#### 非回溯RegExp引擎
- 默认使用NFA引擎，用表达式匹配文本，而表达式又有若干分支和范围。一个分支或者范围匹配失败并不意味着最终匹配失败，正则引擎会去尝试下一个分支或者范围。此时，回溯在正则中的含义是吐出已经匹配过的文本
- 为了解决这个问题，从v8.8开始，V8附带了一个新的实验性——非回溯RegExp引擎，它可以保证**在字符串长度变大情况下保持线性时间变化**

#### 分支预测
- CPU流水线机制​：现代CPU采用指令流水线技术（读取→解码→执行→访存→写回），并行处理指令以提升效率。遇到if分支时，CPU会提前预测分支方向（基于历史执行记录），预加载指令到流水线。若预测正确，流水线持续运行；若预测错误，需清空流水线并重新加载指令，浪费约20 个时钟周期。
- 提升性能的技巧：通过位运算消除if分支，避免依赖分支预测。但视场景决定是否使用，权衡好可读性与性能，如密集计算任务下可考虑使用位运算
